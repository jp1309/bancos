# -*- coding: utf-8 -*-
"""
Modulo 3: Perdidas y Ganancias
Analisis de resultados y rentabilidad del sistema bancario.
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pathlib import Path
import sys

sys.path.append(str(Path(__file__).parent.parent))

from utils.data_loader import cargar_pyg, obtener_fechas_disponibles

# =============================================================================
# CONFIGURACION
# =============================================================================

st.set_page_config(
    page_title="Perdidas y Ganancias | Radar Bancario",
    page_icon="ðŸ’°",
    layout="wide",
)

# Mapeo de cuentas principales de PYG
CUENTAS_PYG = {
    'MNI': 'Margen Neto de Intereses',
    'MBF': 'Margen Bruto Financiero',
    'MNF': 'Margen Neto Financiero',
    'MDI': 'Margen de IntermediaciÃ³n',
    'MOP': 'Margen Operacional',
    'GAI': 'Ganancia Antes de Impuestos',
    'GDE': 'Ganancia del Ejercicio',
}

# Colores para bancos
COLORES_BANCOS = px.colors.qualitative.Set2 + px.colors.qualitative.Pastel1

# =============================================================================
# FUNCIONES DE DATOS
# =============================================================================

@st.cache_data
def obtener_ranking_rentabilidad(df: pd.DataFrame, fecha, codigo: str) -> pd.DataFrame:
    """Obtiene ranking de bancos por rentabilidad en una fecha."""
    df_fecha = df[(df['fecha'] == fecha) & (df['codigo'] == codigo)].copy()
    df_fecha['valor_millones'] = df_fecha['valor_12m'] / 1000
    df_fecha = df_fecha.sort_values('valor_millones', ascending=False)
    return df_fecha[['banco', 'valor_12m', 'valor_millones']]


@st.cache_data
def obtener_evolucion_margen(df: pd.DataFrame, banco: str, codigo: str) -> pd.DataFrame:
    """Obtiene serie temporal de un margen para un banco."""
    df_filtrado = df[(df['banco'] == banco) & (df['codigo'] == codigo)].copy()
    df_filtrado = df_filtrado.sort_values('fecha')
    df_filtrado['valor_millones'] = df_filtrado['valor_12m'] / 1000
    return df_filtrado[['fecha', 'valor_12m', 'valor_millones']].dropna()


@st.cache_data
def obtener_cascada_margenes(df: pd.DataFrame, banco: str, fecha) -> pd.DataFrame:
    """Prepara datos para grafico de cascada de margenes."""
    codigos_cascada = ['MNI', 'MBF', 'MNF', 'MDI', 'MOP', 'GAI', 'GDE']

    df_filtrado = df[
        (df['banco'] == banco) &
        (df['fecha'] == fecha) &
        (df['codigo'].isin(codigos_cascada))
    ].copy()

    df_filtrado['valor_millones'] = df_filtrado['valor_12m'] / 1000
    df_filtrado['orden'] = df_filtrado['codigo'].map({c: i for i, c in enumerate(codigos_cascada)})
    df_filtrado = df_filtrado.sort_values('orden')

    return df_filtrado[['codigo', 'cuenta', 'valor_millones']]


@st.cache_data
def obtener_comparacion_sistema(df: pd.DataFrame, fecha, codigo: str) -> pd.DataFrame:
    """Obtiene datos para comparar bancos en una fecha."""
    df_fecha = df[(df['fecha'] == fecha) & (df['codigo'] == codigo)].copy()
    df_fecha['valor_millones'] = df_fecha['valor_12m'] / 1000

    # Calcular participacion
    total_sistema = df_fecha['valor_millones'].sum()
    df_fecha['participacion'] = (df_fecha['valor_millones'] / total_sistema * 100) if total_sistema > 0 else 0

    df_fecha = df_fecha.sort_values('valor_millones', ascending=False)
    return df_fecha[['banco', 'valor_millones', 'participacion']]


@st.cache_data
def obtener_crecimiento_anual_pyg(df: pd.DataFrame, codigo: str, fecha_actual, fecha_anterior) -> pd.DataFrame:
    """Calcula crecimiento anual de un indicador PYG."""
    df_actual = df[(df['fecha'] == fecha_actual) & (df['codigo'] == codigo)][['banco', 'valor_12m']].copy()
    df_anterior = df[(df['fecha'] == fecha_anterior) & (df['codigo'] == codigo)][['banco', 'valor_12m']].copy()

    df_merged = df_actual.merge(df_anterior, on='banco', suffixes=('_actual', '_anterior'))

    df_merged['crecimiento'] = (
        (df_merged['valor_12m_actual'] - df_merged['valor_12m_anterior']) /
        df_merged['valor_12m_anterior'].abs() * 100
    )

    df_merged['valor_millones'] = df_merged['valor_12m_actual'] / 1000
    df_merged = df_merged.sort_values('crecimiento', ascending=True)

    return df_merged[['banco', 'crecimiento', 'valor_millones']]


# =============================================================================
# PAGINA PRINCIPAL
# =============================================================================

def main():
    st.title("ðŸ’° Perdidas y Ganancias")
    st.markdown("Analisis de perdidas y ganancias del sistema bancario ecuatoriano.")

    # Cargar datos
    try:
        df_pyg, calidad = cargar_pyg()
    except Exception as e:
        st.error(f"Error al cargar datos de PYG: {e}")
        return

    # Lista de bancos y fechas
    bancos = sorted(df_pyg['banco'].unique().tolist())
    fechas = obtener_fechas_disponibles(df_pyg)

    # Filtrar solo registros con valor_12m valido
    df_pyg = df_pyg[df_pyg['valor_12m'].notna()]

    # ==========================================================================
    # SIDEBAR - FILTROS
    # ==========================================================================

    st.sidebar.markdown("### Configuracion")

    # Seleccion de fecha
    fecha_seleccionada = st.sidebar.selectbox(
        "Fecha",
        options=fechas,
        format_func=lambda x: x.strftime("%B %Y"),
        index=0
    )

    # Calcular fecha del aÃ±o anterior
    fecha_anterior = fecha_seleccionada - pd.DateOffset(months=12)
    if fecha_anterior not in fechas:
        fecha_anterior = None

    st.sidebar.markdown("---")
    st.sidebar.markdown(f"**Fecha seleccionada:** {fecha_seleccionada.strftime('%b %Y')}")
    st.sidebar.markdown(f"**Bancos disponibles:** {len(bancos)}")
    if fecha_anterior:
        st.sidebar.markdown(f"**Comparacion anual vs:** {fecha_anterior.strftime('%b %Y')}")

    # ==========================================================================
    # SECCION 1: KPIS DEL SISTEMA
    # ==========================================================================

    st.markdown("### Indicadores del Sistema Bancario")
    st.caption(f"Suma movil 12 meses al {fecha_seleccionada.strftime('%B %Y')}")

    # Calcular KPIs principales
    df_fecha = df_pyg[df_pyg['fecha'] == fecha_seleccionada]

    kpis = {}
    for codigo, nombre in CUENTAS_PYG.items():
        df_codigo = df_fecha[df_fecha['codigo'] == codigo]
        if not df_codigo.empty:
            kpis[codigo] = df_codigo['valor_12m'].sum() / 1000  # Millones

    # Mostrar KPIs en columnas
    cols = st.columns(4)

    with cols[0]:
        valor = kpis.get('MNI', 0)
        st.metric(
            "Margen Neto Intereses",
            f"${valor:,.0f}M",
            help="Ingresos por intereses - Gastos por intereses"
        )

    with cols[1]:
        valor = kpis.get('MOP', 0)
        st.metric(
            "Margen Operacional",
            f"${valor:,.0f}M",
            help="Resultado despues de gastos operacionales"
        )

    with cols[2]:
        valor = kpis.get('GAI', 0)
        st.metric(
            "Ganancia Antes Impuestos",
            f"${valor:,.0f}M",
            help="Resultado antes de impuestos"
        )

    with cols[3]:
        valor = kpis.get('GDE', 0)
        st.metric(
            "Ganancia del Ejercicio",
            f"${valor:,.0f}M",
            help="Resultado neto del ejercicio"
        )

    st.markdown("---")

    # ==========================================================================
    # SECCION 2: RANKING DE RENTABILIDAD
    # ==========================================================================

    st.markdown("### Ranking de Rentabilidad")
    st.caption("Ganancia del Ejercicio por banco (suma movil 12 meses)")

    col_config, col_chart = st.columns([1, 3])

    with col_config:
        top_n = st.slider("Mostrar top", min_value=5, max_value=len(bancos), value=15, step=5)

    with col_chart:
        ranking = obtener_ranking_rentabilidad(df_pyg, fecha_seleccionada, 'GDE')
        ranking_top = ranking.head(top_n)

        if not ranking_top.empty:
            fig_rank = px.bar(
                ranking_top,
                x='valor_millones',
                y='banco',
                orientation='h',
                title=f"Top {top_n} Bancos por Ganancia",
                labels={'valor_millones': 'Millones USD', 'banco': ''},
                color='valor_millones',
                color_continuous_scale='Blues',
            )
            fig_rank.update_layout(
                height=max(400, len(ranking_top) * 25),
                showlegend=False,
                margin=dict(l=10, r=10, t=40, b=10)
            )
            st.plotly_chart(fig_rank, use_container_width=True)

    st.markdown("---")

    # ==========================================================================
    # SECCION 3: CRECIMIENTO ANUAL
    # ==========================================================================

    if fecha_anterior:
        st.markdown("### Crecimiento Anual de Rentabilidad")
        st.caption(f"Variacion vs mismo mes del aÃ±o anterior ({fecha_seleccionada.strftime('%B %Y')})")

        col_gde, col_mop = st.columns(2)

        with col_gde:
            st.markdown("**Ganancia del Ejercicio**")

            df_crec = obtener_crecimiento_anual_pyg(df_pyg, 'GDE', fecha_seleccionada, fecha_anterior)

            if not df_crec.empty:
                fig_gde = go.Figure(go.Bar(
                    x=df_crec['crecimiento'],
                    y=df_crec['banco'],
                    orientation='h',
                    marker=dict(
                        color=df_crec['crecimiento'],
                        colorscale='RdYlGn',
                        cmin=-50,
                        cmax=50,
                    ),
                    text=df_crec['crecimiento'].apply(lambda x: f"{x:.1f}%"),
                    textposition='outside',
                    hovertemplate='<b>%{y}</b><br>Crecimiento: %{x:.1f}%<br>Valor: $%{customdata:.0f}M<extra></extra>',
                    customdata=df_crec['valor_millones']
                ))

                fig_gde.update_layout(
                    title="Crecimiento Anual (%)",
                    height=max(400, len(df_crec) * 20),
                    xaxis_title="Crecimiento (%)",
                    yaxis_title="",
                    showlegend=False,
                    margin=dict(l=10, r=10, t=40, b=10)
                )

                fig_gde.add_vline(x=0, line_dash="dash", line_color="gray", line_width=1)
                st.plotly_chart(fig_gde, use_container_width=True)
            else:
                st.info("No hay datos para comparar.")

        with col_mop:
            st.markdown("**Margen Operacional**")

            df_crec = obtener_crecimiento_anual_pyg(df_pyg, 'MOP', fecha_seleccionada, fecha_anterior)

            if not df_crec.empty:
                fig_mop = go.Figure(go.Bar(
                    x=df_crec['crecimiento'],
                    y=df_crec['banco'],
                    orientation='h',
                    marker=dict(
                        color=df_crec['crecimiento'],
                        colorscale='RdYlGn',
                        cmin=-50,
                        cmax=50,
                    ),
                    text=df_crec['crecimiento'].apply(lambda x: f"{x:.1f}%"),
                    textposition='outside',
                    hovertemplate='<b>%{y}</b><br>Crecimiento: %{x:.1f}%<br>Valor: $%{customdata:.0f}M<extra></extra>',
                    customdata=df_crec['valor_millones']
                ))

                fig_mop.update_layout(
                    title="Crecimiento Anual (%)",
                    height=max(400, len(df_crec) * 20),
                    xaxis_title="Crecimiento (%)",
                    yaxis_title="",
                    showlegend=False,
                    margin=dict(l=10, r=10, t=40, b=10)
                )

                fig_mop.add_vline(x=0, line_dash="dash", line_color="gray", line_width=1)
                st.plotly_chart(fig_mop, use_container_width=True)
            else:
                st.info("No hay datos para comparar.")

        st.markdown("---")

    # ==========================================================================
    # SECCION 4: CASCADA DE MARGENES POR BANCO
    # ==========================================================================

    st.markdown("### Cascada de Margenes por Banco")
    st.caption("Descomposicion de la formacion del resultado")

    col_banco_sel, col_cascada = st.columns([1, 3])

    with col_banco_sel:
        banco_seleccionado = st.selectbox(
            "Seleccionar banco",
            options=bancos,
            index=0
        )

    with col_cascada:
        df_cascada = obtener_cascada_margenes(df_pyg, banco_seleccionado, fecha_seleccionada)

        if not df_cascada.empty and len(df_cascada) > 0:
            # Preparar datos para waterfall
            valores = df_cascada['valor_millones'].tolist()
            etiquetas = [CUENTAS_PYG.get(c, c) for c in df_cascada['codigo'].tolist()]

            fig_cascada = go.Figure(go.Waterfall(
                name="Margenes",
                orientation="v",
                measure=["relative"] * len(valores),
                x=etiquetas,
                y=valores,
                text=[f"${v:,.0f}M" for v in valores],
                textposition="outside",
                connector={"line": {"color": "rgb(63, 63, 63)"}},
            ))

            fig_cascada.update_layout(
                title=f"Formacion del Resultado - {banco_seleccionado}",
                height=450,
                xaxis_title="",
                yaxis_title="Millones USD",
                showlegend=False,
                margin=dict(l=10, r=10, t=40, b=100)
            )

            fig_cascada.update_xaxes(tickangle=-45)

            st.plotly_chart(fig_cascada, use_container_width=True)
        else:
            st.warning("No hay datos disponibles para este banco en la fecha seleccionada.")

    st.markdown("---")

    # ==========================================================================
    # SECCION 5: EVOLUCION TEMPORAL COMPARATIVA
    # ==========================================================================

    st.markdown("### Evolucion Temporal de Rentabilidad")
    st.caption("Comparacion de multiples bancos en el tiempo (suma movil 12 meses)")

    col_config_evol, col_chart_evol = st.columns([1, 3])

    with col_config_evol:
        # Seleccion de bancos
        bancos_seleccionados = st.multiselect(
            "Seleccionar bancos",
            options=bancos,
            default=bancos[:5] if len(bancos) >= 5 else bancos,
            max_selections=8
        )

        # Seleccion de indicador
        indicador_seleccionado = st.selectbox(
            "Indicador",
            options=list(CUENTAS_PYG.keys()),
            format_func=lambda x: CUENTAS_PYG[x],
            index=6  # GDE por defecto
        )

    with col_chart_evol:
        if bancos_seleccionados:
            fig_evol = go.Figure()

            for i, banco in enumerate(bancos_seleccionados):
                serie = obtener_evolucion_margen(df_pyg, banco, indicador_seleccionado)

                if not serie.empty:
                    fig_evol.add_trace(go.Scatter(
                        x=serie['fecha'],
                        y=serie['valor_millones'],
                        name=banco,
                        mode='lines',
                        line=dict(width=2, color=COLORES_BANCOS[i % len(COLORES_BANCOS)]),
                        hovertemplate='<b>%{fullData.name}</b><br>' +
                                      'Fecha: %{x|%b %Y}<br>' +
                                      'Valor: $%{y:,.0f}M<br>' +
                                      '<extra></extra>'
                    ))

            fig_evol.update_layout(
                title=f"Evolucion: {CUENTAS_PYG[indicador_seleccionado]}",
                height=450,
                xaxis_title="Fecha",
                yaxis_title="Millones USD (12M)",
                hovermode="x unified",
                legend=dict(orientation="h", y=-0.15, x=0.5, xanchor="center"),
                margin=dict(l=10, r=10, t=40, b=80)
            )

            st.plotly_chart(fig_evol, use_container_width=True)
        else:
            st.info("Selecciona al menos un banco para visualizar.")

    st.markdown("---")

    # ==========================================================================
    # SECCION 6: DISTRIBUCION DE RENTABILIDAD
    # ==========================================================================

    st.markdown("### Distribucion de Rentabilidad del Sistema")
    st.caption(f"Participacion en ganancia del ejercicio - {fecha_seleccionada.strftime('%B %Y')}")

    comparacion = obtener_comparacion_sistema(df_pyg, fecha_seleccionada, 'GDE')

    # Filtrar solo valores positivos para el pie chart
    comparacion_positiva = comparacion[comparacion['valor_millones'] > 0]

    if not comparacion_positiva.empty:
        # Mostrar solo top 10 + otros
        if len(comparacion_positiva) > 10:
            top_10 = comparacion_positiva.head(10)
            otros_valor = comparacion_positiva.iloc[10:]['valor_millones'].sum()
            otros_part = comparacion_positiva.iloc[10:]['participacion'].sum()

            otros_row = pd.DataFrame({
                'banco': ['Otros'],
                'valor_millones': [otros_valor],
                'participacion': [otros_part]
            })

            comparacion_plot = pd.concat([top_10, otros_row], ignore_index=True)
        else:
            comparacion_plot = comparacion_positiva

        fig_pie = px.pie(
            comparacion_plot,
            values='valor_millones',
            names='banco',
            title="Distribucion de Ganancia por Banco",
            hole=0.4,
            color_discrete_sequence=px.colors.qualitative.Set3
        )

        fig_pie.update_traces(
            textinfo='percent+label',
            hovertemplate='<b>%{label}</b><br>Valor: $%{value:,.0f}M<br>Participacion: %{percent}<extra></extra>'
        )

        fig_pie.update_layout(
            height=500,
            margin=dict(l=10, r=10, t=40, b=10)
        )

        st.plotly_chart(fig_pie, use_container_width=True)
    else:
        st.warning("No hay datos de rentabilidad positiva para mostrar en esta fecha.")


if __name__ == "__main__":
    main()
